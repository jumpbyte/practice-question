## 题意概述

有一个二叉树形式的任务依赖结构，我们有两个 CPU 核，这两个核可以同时执行不同的任务，问执行完所有任务的最小时间，也即是希望两个 CPU 核的并行时间尽可能大。

### 题目解析

这道题虽然代码量很少，但思维难度较高。

在通过对示例的观察后，我们可以得出以下重要结论：
1. **对于任何一颗任务树，它一定有一个先并行后串行的最优策略。树的根结点只能串行。** 这个结论的正确性是因为只有在这颗任务树退化成一个链以后，它才不能被并行，所以把串行延后执行不会导致执行时间变长。
2. 设一颗任务树的所有任务时间之和为 $x$ ，最大并行时间为 $y$ ，那么这个任务最少需要 $x - y$ 的时间完成。 其中前 $y$ 秒用于并行，后 $x - 2y$ 秒用于串行。 注意由于上一条结论，在区间 $[x - 2y, x]$ 内的所有剩余时间都是可以 **只通过** 并行取到的。对于叶子节点 `node` 来说，它的任务总时间即为 `node.val` ，最大并行时间为 0 。

所有任务时间之和很容易求，下面我们求最大并行时间。

### 解法一

设一颗任务树的左子树所有任务时间和为 $a$ ，最大并行时间为 $b$ ，右子树分别为 $c, d$ 。那么这颗任务树最大并行时间为 $\frac{a + c}{2}$，但不一定能取到。

不失一般性，假设 $a \geq c$ 。如果 $a - 2b \leq c$ ，那么最优策略是左树先并行 $a - c$ 的任务，剩余 $c$ 的任务量，然后再两树并行，就达成了一直并行。并行时间取到了 $\frac{a + c}{2}$ 。

如果 $a - 2b > c$ ，那么剩余 $a - 2b - c$ 的任务无法被并行。并行时间最大为 $b + c$ 。

#### 题解代码

* [sol1-Python]

```python
# Definition for a binary tree node.
# class ceeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def minimalExecTime(self, root):
        """
        :type root: TreeNode
        :rtype: float
        """
        def dfs(root):
            if root is None:
                return 0., 0.
            tc = root.val
			
            # 先递归左右子树
            a, b = dfs(root.left)
            c, d = dfs(root.right)
            
            tc = tc + a + c
            # 只考虑 a >= c 的情况，不满足就交换
            if a < c:
                a, c = c, a
                b, d = d, b
            
            if a - 2 * b <= c:
                pc = (a + c) / 2
            else:
                pc = c + b

            return tc, pc

        tc, pc = dfs(root)
        return tc - pc
```

* [sol1-C++]

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    pair<int, double> DFS(TreeNode* root) {
        if (!root) return {0, 0.0};
        auto l = DFS(root->left);
        auto r = DFS(root->right);

        int a = l.first, c = r.first;
        double b = l.second, d = r.second;
        int tot = a + c + root->val;
        if ((c - 2 * d <= a && a <= c) || (a - 2 * b <= c && c <= a)) {
            return {tot, (a + c) / 2.0};
        }
        if (a - 2 * b > c) {
            return {tot, b + c};
        } else {
            // c - 2 * d > a
            return {tot, a + d};
        }
    }
    double minimalExecTime(TreeNode* root) {
        auto p = DFS(root);
        return p.first - p.second;
    }
};
```

#### 复杂度分析

* 时间复杂度：$O(n)$。每个节点只被访问一次。

* 空间复杂度：$O(n)$。

### 解法二

虽然解法一已经很清晰了，解法二比解法一更简洁。它的思路是从解法一的基础上得来的。

我们沿用解法一的记号，设一颗任务树的左子树所有任务时间和为 $a$ ，最大并行时间为 $b$ ，右子树分别为 $c, d$ 。不失一般性，假设 $a \geq c$ 。

记这颗任务树的根任务的运行时间为 `val` 。如果 $a - 2b \leq c$ ，则所有子树上的任务都被并行执行了，所以这颗任务树的最短执行时间为 $\frac{a + c}{2} + val$ 。否则，这颗任务树的最短执行时间为 $a - b + val$ 。

通过对以上两种情况的合并，以及考虑到 $a < c$ 的情况，最终我们可以用一个公式直接算出这颗任务树的最短执行时间为

$\max(a - b, c - d, \frac{a + c}{2}) + val$

又由于 $a - b$, $c - d$ 正好是左右子树的最短执行时间（记为函数 $ans$ ），我们可以进一步简化这个公式：

$ans(root) = \max(ans(root.left), ans(root.right), \frac{a + c}{2}) + val$

使用 DFS 就可以轻松求解了。

* C++

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    pair<int, double> DFS(TreeNode* root) {
        if (!root) return {0, 0.0};
        auto l = DFS(root->left);
        auto r = DFS(root->right);

        return {l.first + r.first + root->val, root->val + max(max(l.second, r.second), (l.first + r.first) / 2.0)};
    }
    double minimalExecTime(TreeNode* root) {
        auto p = DFS(root);
        return p.second;
    }
};
```

#### 复杂度分析

* 时间复杂度：$O(n)$。每个节点只被访问一次。

* 空间复杂度：$O(n)$。

