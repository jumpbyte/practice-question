# 题目

* 

```
小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。

字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 "abe" 的数值等于 1 + 2 + 5 = 8 。

给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。

注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况：

x 是 y 的一个前缀；
如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。
```

# 题目分析

这个题目是要构造一个字符串，满足三个条件：
1. 长度为`n`；
2. 字符和为`k`；【字符的值等于其在字母表中的顺序，且字符全为小写字母】
3. 字典序最小；【也就是说这个字符串在所有满足前两个条件的结果中，排序要靠前，也就是说字符串中越靠前的字符要尽可能的小，如`aab`就比`bab`排序靠前，因为首个字符`a`小于`b`】

因为字符和是固定为`k`，那么**如果靠前的字母要尽可能的小，意味着靠后的字母就要尽可能的大**。
因此我们从第`1`位到第`n`位构造字符串的时候：在构造第`i`位时，假设距离目标值`k`还差`t`，后面的`(n - i)`位全为最大字母`z`时【和最大的情况，如果可以满足，说明后面的字母还可以调小】，是否能够满足和为`t`:
- 如果`(n - i) * 26 >= t`, 即`t - (n - i) * 26 <= 0`，说明后面的`(n - i)`位全为最大字母`z`时，得到的字母和会超过当前目标值`t`，那么当前这个第`i`就可以取最小字符`a`，因为后面的值可以满足目标值，后面的值不需要用字母`z`，还可以调小；
- 如果`(n - i) * 26 < t`, 即`t - (n - i) * 26 > 0`，说明后面的`(n - i)`位全为最大字母`z`时，得到的字母和还不够当前目标值`t`，那么差的这部分`t - (n - i) * 26`，就需要第`i`位来填补，填补的字符就是差值`bias = t - (n - i) * 26`对应的字符。

# 代码

- 使用`StringBuilder`逐个字符插入的构造字符串
- 定义一个变量`bias`来统计差值
- 得到差值`bias`对应的字符的代码为`(char)('a' - 1 + bias)`，`'a'-1`表示从字母`a`的前一个字符开始加上差值，才能正确得到差值对应的字符

* 

```
class Solution {
    public String getSmallestString(int n, int k) {
        StringBuilder sb = new StringBuilder();
        int bias;
        for(int i = 1; i <= n; i++){
            bias = k - 26 * (n - i);    // 计算贪心得到的差值
            if(bias > 0){
                sb.append((char)('a' - 1 + bias));
                k -= bias;  // 当前位使用了bias对应的字符，目标值减小bias
            }else{
                sb.append('a');
                k -= 1; // 当前为使用字符a，对应值为1，目标值减小1
            }
        }
        return sb.toString();
    }
}
```

